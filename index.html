<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <title>ACC étendue – Étude PMO (IGN, INSEE, centre libre, emprise producteur)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <!-- Leaflet -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" crossorigin="" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" crossorigin=""></script>
  <!-- Turf.js pour buffers et géométrie -->
  <script src="https://unpkg.com/@turf/turf@6.5.0/turf.min.js"></script>
  <!-- Leaflet EasyPrint (export image rapide) -->
  <script src="https://unpkg.com/leaflet-easyprint@2.1.9/dist/bundle.min.js"></script>
  <style>
    :root{
      --bg:#0f1221; --panel:#14182b; --muted:#8c94af; --text:#e7ebff;
      --accent:#5dd39e; --warn:#ffb020; --bad:#ff5c7a; --prod:#ff7a00; --cons:#2ea8ff; --sdis:#9b59b6;
    }
    *{box-sizing:border-box}
    body{
      margin:0; font-family:Inter,system-ui,Segoe UI,Roboto,Arial,sans-serif;
      color:var(--text); background:linear-gradient(180deg,#0f1221,#0b0e1a);
      height:100dvh; display:flex; gap:12px; padding:12px;
    }
    #sidebar{
      width:470px; max-width:100%; background:var(--panel); border:1px solid #222845;
      border-radius:12px; padding:14px; overflow:auto;
    }
    h1{font-size:18px; margin:0 0 8px 0}
    .sub{color:var(--muted); font-size:12px; margin-bottom:10px}
    fieldset{border:1px solid #232947; border-radius:10px; margin:12px 0; padding:12px}
    legend{padding:0 6px; color:var(--muted); font-size:12px}
    label{display:block; margin:6px 0}
    .row{display:flex; gap:8px; flex-wrap:wrap}
    .btn{
      background:#1a2040; color:var(--text); border:1px solid #2a315b; padding:8px 10px;
      border-radius:8px; cursor:pointer; font-weight:600
    }
    .btn:hover{background:#1e2550}
    .btn.danger{border-color:#4b2340; background:#2a1830}
    .btn.danger:hover{background:#351a36}
    .btn.secondary{background:#101435; border-color:#2a315b; color:#c7ceef}
    .type{
      display:flex; align-items:center; gap:8px; padding:6px 8px; border:1px solid #2a315b;
      border-radius:8px; cursor:pointer; background:#151935
    }
    .type input{margin:0}
    .dot{width:10px; height:10px; border-radius:50%}
    .dot.prod{background:var(--prod)}
    .dot.cons{background:var(--cons)}
    .dot.sdis{background:var(--sdis)}
    textarea{
      width:100%; min-height:90px; resize:vertical; background:#0f1330; color:var(--text);
      border:1px solid #2a315b; border-radius:8px; padding:8px; font-family:ui-monospace,Consolas,Menlo,monospace
    }
    input[type="number"], input[type="text"], input[type="file"]{
      background:#0f1330; color:var(--text); border:1px solid #2a315b; border-radius:8px; padding:8px;
    }
    #map{flex:1; min-width:300px; border:1px solid #222845; border-radius:12px}
    .hint{color:var(--muted); font-size:12px}
    .status{padding:10px; border-radius:10px; margin-top:8px; font-weight:700}
    .ok{background:rgba(93,211,158,.12); border:1px solid rgba(93,211,158,.5); color:var(--accent)}
    .bad{background:rgba(255,92,122,.12); border:1px solid rgba(255,92,122,.5); color:var(--bad)}
    .warn{background:rgba(255,176,32,.12); border:1px solid rgba(255,176,32,.5); color:var(--warn)}
    .legend{display:grid; grid-template-columns:auto 1fr; gap:6px 10px; align-items:center; margin-top:6px}
    .muted{color:var(--muted)}
    .small{font-size:12px}
    .mono{font-family:ui-monospace,Consolas,Menlo,monospace}
    .selectable.selected{outline:2px dashed #5dd39e; outline-offset:4px}
    .pill{display:inline-block; padding:2px 6px; border-radius:999px; border:1px solid #2a315b; color:var(--muted); font-size:12px}
  </style>
</head>
<body>
  <div id="sidebar">
    <h1>ACC étendue – Étude PMO</h1>
    <div class="sub">IGN + INSEE · Centre libre ou Emprise producteur · Haversine ≈ · 2/10/20 km</div>

    <fieldset>
      <legend>1) Participants</legend>
      <div class="hint">Choisis un type puis clique sur la carte pour ajouter un point.</div>
      <div class="row" role="radiogroup" aria-label="Type de point">
        <label class="type"><input type="radio" name="ptype" value="consumer" checked><span class="dot cons"></span>Consommateur</label>
        <label class="type"><input type="radio" name="ptype" value="producer"><span class="dot prod"></span>Producteur</label>
        <label class="type"><input type="radio" name="ptype" value="sdis"><span class="dot sdis"></span>SDIS</label>
      </div>
      <div class="row">
        <button id="clearAll" class="btn danger">Effacer tous les points</button>
        <button id="exportCsv" class="btn secondary">Exporter CSV</button>
        <button id="fitBtn" class="btn secondary">Ajuster la vue</button>
      </div>
      <div id="count" class="hint">Aucun point saisi pour l’instant.</div>
      <div class="small muted">Suppression rapide: Alt+clic ou clic droit sur un marqueur, ou sélection puis touche Suppr.</div>
    </fieldset>

    <fieldset>
      <legend>2) Import (optionnel)</legend>
      <div class="hint">Coller une liste <span class="mono">Nom;Lat;Lon;Type</span> — ex. <span class="mono">Usine A;45.76;4.84;consumer</span></div>
      <textarea id="importArea" placeholder="Nom;45.76;4.84;consumer"></textarea>
      <div class="row">
        <button id="importBtn" class="btn">Importer la liste</button>
      </div>
      <div class="hint">Ou importer une emprise producteur au format GeoJSON (Polygon/Multipolygon):</div>
      <div class="row">
        <input type="file" id="empriseFile" accept=".geojson,.json">
        <button id="clearEmprise" class="btn secondary">Retirer l’emprise</button>
      </div>
    </fieldset>

    <fieldset>
      <legend>3) Périmètre cible</legend>
      <div class="row">
        <label><input type="radio" name="radius" value="2" checked> 2 km (droit commun)</label>
        <label><input type="radio" name="radius" value="10"> 10 km (dérogation périurbaine)</label>
        <label><input type="radio" name="radius" value="20"> 20 km (dérogation rurale)</label>
      </div>
      <div class="row" style="margin-top:6px">
        <label>Personnalisé : <input id="customRadius" type="number" min="0" step="0.1" placeholder="km" style="width:120px"> km
          <span class="hint">Laisse vide pour utiliser 2/10/20</span>
        </label>
      </div>
      <div class="row" style="margin-top:6px">
        <label class="pill"><input id="showCircles" type="checkbox"> Cercles autour de chaque participant</label>
        <label class="pill" title="Par défaut, le SDIS n’influence pas la distance réglementaire"><input id="includeSdis" type="checkbox"> Inclure SDIS au calcul</label>
      </div>
      <div class="row" style="margin-top:6px">
        <label class="pill"><input id="freeCenter" type="radio" name="mode" value="free" checked> Mode centre libre</label>
        <label class="pill"><input id="empriseMode" type="radio" name="mode" value="emprise"> Mode emprise producteur</label>
        <label class="pill"><input id="maxDist" type="radio" name="mode" value="pair"> Distance max entre participants</label>
      </div>

      <div id="report" class="status warn">En attente de points…</div>
      <div id="details" class="small muted"></div>
    </fieldset>

    <fieldset>
      <legend>Cartes et données</legend>
      <div class="hint">Fonds: OSM, OpenTopo, Carto Light, IGN (clé Geoportail requise). Overlay INSEE rural/périurbain.</div>
      <div class="row">
        <input id="ignKey" type="text" placeholder="Clé API IGN Géoportail (optionnel)" style="flex:1">
        <button id="useIgn" class="btn secondary">Activer IGN</button>
      </div>
      <div class="row">
        <button id="toggleInsee" class="btn secondary">Afficher/masquer grille INSEE</button>
        <button id="printMap" class="btn secondary">Exporter image de la carte</button>
      </div>
      <div class="hint small">Place ton fichier INSEE ici: <span class="mono">/data/insee_grille.geojson</span></div>
    </fieldset>

    <fieldset>
      <legend>Légende</legend>
      <div class="legend">
        <span class="dot prod"></span><span>Producteur</span>
        <span class="dot cons"></span><span>Consommateur</span>
        <span class="dot sdis"></span><span>SDIS</span>
      </div>
    </fieldset>

    <fieldset>
      <legend>Rappels officiels (synthèse)</legend>
      <ul class="small muted" style="margin:0 0 0 16px; padding:0 0 0 6px; list-style:disc">
        <li>ACC étendue ≤ 20 km = dérogation ministérielle (PMO), en zone rurale (grille INSEE).</li>
        <li>La distance s’apprécie entre les deux participants les plus éloignés (mode “distance max”).</li>
        <li>L’adhésion du SDIS à la PMO n’étend pas, à elle seule, le périmètre.</li>
        <li>Anticiper les exigences SDIS (coupures, cheminements, DECI / RDDECI) pour chaque site.</li>
      </ul>
    </fieldset>
  </div>

  <div id="map" aria-label="Carte interactive"></div>

  <script>
    // --- Map init (centrée sur Auvergne–Rhône–Alpes) ---
    const map = L.map('map', { zoomControl: true }).setView([45.5, 5.7], 8);

    // Basemaps (en ligne)
    const osm = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',{ maxZoom: 19, attribution:'© OpenStreetMap' }).addTo(map);
    const topo = L.tileLayer('https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png',{ maxZoom: 17, attribution:'© OpenTopoMap, © OpenStreetMap' });
    const cartoLight = L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}.png',{ maxZoom: 19, attribution:'© Carto, © OpenStreetMap' });
    let ignLayer = null;

    const baseLayers = {"OSM Standard": osm, "OpenTopoMap": topo, "Carto Light": cartoLight};
    const overlays = {};
    L.control.layers(baseLayers, overlays, { position: 'topleft', collapsed: true }).addTo(map);

    // Contrôle impression
    const printer = L.easyPrint({ tileLayer: osm, sizeModes: ['A4Portrait','A4Landscape'], filename: 'acc_etendue_carte', exportOnly: true, hideControlContainer: false }).addTo(map);

    // --- State ---
    const points = []; // {id,name,lat,lon,type,marker}
    const circles = [];
    let idSeq = 1;
    let selectedPointId = null;
    let accCircle = null, accCenterMarker = null;

    // Emprise producteur
    let empriseLayer = null;           // couche GeoJSON emprise
    let empriseBufferLayer = null;     // buffer à R km

    // INSEE overlay
    let inseeLayer = null;
    let inseeVisible = false;

    // --- UI elements ---
    const countEl = document.getElementById('count');
    const reportEl = document.getElementById('report');
    const detailsEl = document.getElementById('details');
    const customRadiusEl = document.getElementById('customRadius');
    const showCirclesEl = document.getElementById('showCircles');
    const includeSdisEl = document.getElementById('includeSdis');
    const ignKeyEl = document.getElementById('ignKey');

    // Modes
    const modeFreeEl = document.getElementById('freeCenter');
    const modeEmpriseEl = document.getElementById('empriseMode');
    const modePairEl = document.getElementById('maxDist');

    // --- Helpers ---
    function selectedType(){ return document.querySelector('input[name="ptype"]:checked').value; }
    function selectedRadiusKm(){
      const v = customRadiusEl.value.trim();
      if(v !== '' && !isNaN(v)) return Math.max(0, parseFloat(v));
      return parseFloat(document.querySelector('input[name="radius"]:checked').value);
    }
    function selectedMode(){ return document.querySelector('input[name="mode"]:checked').value; }
    function typeColor(t){ if(t==='producer') return 'var(--prod)'; if(t==='consumer') return 'var(--cons)'; return 'var(--sdis)'; }
    function humanType(t){ return t==='producer'?'Producteur':t==='consumer'?'Consommateur':'SDIS'; }
    function updateCount(){
      const n = points.length;
      countEl.textContent = n ? `${n} point${n>1?'s':''} saisi${n>1?'s':''}.` : 'Aucun point saisi pour l’instant.';
    }
    function fitToData(){
      const layers = [];
      points.forEach(p=>layers.push(p.marker));
      if(empriseLayer) layers.push(empriseLayer);
      if(!layers.length) return;
      const group = new L.featureGroup(layers);
      map.fitBounds(group.getBounds().pad(0.2));
    }
    function haversineKm(lat1, lon1, lat2, lon2){
      const R = 6371;
      const toRad = d => d * Math.PI / 180;
      const dLat = toRad(lat2 - lat1);
      const dLon = toRad(lon2 - lon1);
      const a = Math.sin(dLat/2)**2 + Math.cos(toRad(lat1))*Math.cos(toRad(lat2))*Math.sin(dLon/2)**2;
      return 2 * R * Math.asin(Math.sqrt(a));
    }
    function computeMaxDistance(includeSdis=false){
      const eligible = points.filter(p => includeSdis ? true : (p.type!=='sdis'));
      if(eligible.length < 2) return {max:0, pair:null, considered:eligible.length};
      let max = -1, pair = null;
      for(let i=0;i<eligible.length;i++){
        for(let j=i+1;j<eligible.length;j++){
          const a = eligible[i], b = eligible[j];
          const d = haversineKm(a.lat, a.lon, b.lat, b.lon);
          if(d > max){ max = d; pair = [a,b]; }
        }
      }
      return {max, pair, considered:eligible.length};
    }
    function clearCircles(){ circles.forEach(c => map.removeLayer(c)); circles.length = 0; }
    function refreshCircles(){
      clearCircles();
      if(!showCirclesEl.checked) return;
      const r = selectedRadiusKm() * 1000;
      points.forEach(p=>{
        const c = L.circle([p.lat, p.lon], { radius: r, color: typeColor(p.type), weight:1, opacity:0.9, fillOpacity:0.06 }).addTo(map);
        circles.push(c);
      });
    }
    function showAccCircle(center, radiusKm, color='#5dd39e'){
      if(accCircle){ map.removeLayer(accCircle); accCircle = null; }
      if(accCenterMarker){ map.removeLayer(accCenterMarker); accCenterMarker = null; }
      accCircle = L.circle(center, { radius: radiusKm * 1000, color, weight:2, opacity:0.9, fillOpacity:0.05 }).addTo(map);
      accCenterMarker = L.circleMarker(center, {radius:5, color, weight:2, fillOpacity:0.6}).addTo(map);
    }
    function clearAccCircle(){
      if(accCircle){ map.removeLayer(accCircle); accCircle = null; }
      if(accCenterMarker){ map.removeLayer(accCenterMarker); accCenterMarker = null; }
    }
    function projectLocal(pointsLL){
      const lat0 = pointsLL.reduce((s,p)=>s+p.lat,0)/pointsLL.length;
      const lon0 = pointsLL.reduce((s,p)=>s+p.lon,0)/pointsLL.length;
      const pts = pointsLL.map(p=>{
        const x = (p.lon - lon0) * 111.32 * Math.cos(lat0*Math.PI/180);
        const y = (p.lat - lat0) * 111.32;
        return {x, y, ref:p};
      });
      return {lat0, lon0, pts};
    }
    function unprojectLocal(lat0, lon0, x, y){
      const lat = lat0 + y/111.32;
      const lon = lon0 + x/(111.32 * Math.cos(lat0*Math.PI/180));
      return {lat, lon};
    }
    function mec(points){ // Welzl
      function dist(a,b){ return Math.hypot(a.x-b.x,a.y-b.y); }
      function circle2(a,b){ return {x:(a.x+b.x)/2,y:(a.y+b.y)/2,r:dist(a,b)/2}; }
      function circle3(a,b,c){
        const A=b.x-a.x, B=b.y-a.y, C=c.x-a.x, D=c.y-a.y;
        const E=A*(a.x+b.x)+B*(a.y+b.y);
        const F=C*(a.x+c.x)+D*(a.y+c.y);
        const G=2*(A*(c.y-b.y)-B*(c.x-b.x));
        if(Math.abs(G)<1e-12){
          const candidates=[circle2(a,b),circle2(a,c),circle2(b,c)];
          let best=null;
          for(const cc of candidates){
            if([a,b,c].every(p=>dist(p,cc)<=cc.r+1e-9)) if(!best||cc.r<best.r) best=cc;
          }
          return best;
        } else {
          const cx=(D*E-B*F)/G, cy=(A*F-C*E)/G, r=dist({x:cx,y:cy},a);
          return {x:cx,y:cy,r};
        }
      }
      function isIn(c,p){ return Math.hypot(c.x-p.x,c.y-p.y) <= c.r + 1e-9; }
      function welzl(P, R, n){
        if(n===0 || R.length===3){
          if(R.length===0) return {x:0,y:0,r:0};
          if(R.length===1) return {x:R[0].x,y:R[0].y,r:0};
          if(R.length===2) return circle2(R[0],R[1]);
          return circle3(R[0],R[1],R[2]);
        }
        const p = P[n-1];
        const c = welzl(P, R, n-1);
        if(isIn(c,p)) return c;
        return welzl(P, R.concat([p]), n-1);
      }
      const P = points.slice();
      for(let i=P.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [P[i],P[j]]=[P[j],P[i]]; }
      return welzl(P, [], P.length);
    }

    // --- Emprise producteur: gestion & buffer ---
    function clearEmprise(){
      if(empriseLayer){ map.removeLayer(empriseLayer); empriseLayer = null; }
      if(empriseBufferLayer){ map.removeLayer(empriseBufferLayer); empriseBufferLayer = null; }
    }
    function loadEmpriseGeoJSON(geojson){
      clearEmprise();
      empriseLayer = L.geoJSON(geojson, {
        style: {color:'#ff7a00', weight:2, fillOpacity:0.1}
      }).addTo(map);
      fitToData();
      refreshReport();
    }
    function refreshEmpriseBuffer(){
      if(empriseBufferLayer){ map.removeLayer(empriseBufferLayer); empriseBufferLayer = null; }
      if(!empriseLayer) return;
      const rKm = selectedRadiusKm();
      const gj = empriseLayer.toGeoJSON();
      // Buffer en kilomètres (Turf attend des unités)
      const buffered = turf.buffer(gj, rKm, {units:'kilometers'});
      empriseBufferLayer = L.geoJSON(buffered, { style:{color:'#5dd39e', weight:2, dashArray:'6 4', fillOpacity:0.05} }).addTo(map);
    }
    function allEligiblePointsInsideEmpriseBuffer(includeSdis=false){
      if(!empriseLayer) return {ok:false, total:0, inside:0};
      const gjBuffer = empriseBufferLayer ? empriseBufferLayer.toGeoJSON() : null;
      if(!gjBuffer) return {ok:false, total:0, inside:0};
      const eligible = points.filter(p => includeSdis ? true : p.type!=='sdis');
      let inside=0;
      for(const p of eligible){
        const pt = turf.point([p.lon, p.lat]);
        let contained = false;
        turf.flattenEach(gjBuffer, feat=>{
          if(turf.booleanPointInPolygon(pt, feat)) contained = true;
        });
        if(contained) inside++;
      }
      return {ok: inside === eligible.length && eligible.length>0, total:eligible.length, inside};
    }

    // --- Report ---
    function refreshReport(){
      const rKm = selectedRadiusKm();
      const includeSdis = includeSdisEl.checked;
      const mode = selectedMode();

      clearAccCircle();
      if(mode==='emprise'){ refreshEmpriseBuffer(); }

      const eligible = points.filter(p => includeSdis ? true : p.type!=='sdis');

      if(points.length === 0 && mode!=='emprise'){
        reportEl.className = 'status warn';
        reportEl.textContent = 'En attente de points…';
        detailsEl.textContent = '';
        return;
      }

      if(mode==='emprise'){
        if(!empriseLayer){
          reportEl.className = 'status warn';
          reportEl.textContent = 'Importe une emprise producteur (GeoJSON) pour utiliser ce mode.';
          detailsEl.textContent = 'Formats: Polygon ou MultiPolygon (EPSG:4326).';
          return;
        }
        if(eligible.length===0){
          reportEl.className = 'status warn';
          reportEl.textContent = 'Aucun participant éligible à vérifier (SDIS exclu si non coché).';
          detailsEl.textContent = '';
          return;
        }
        const res = allEligiblePointsInsideEmpriseBuffer(includeSdis);
        const ok = res.ok;
        reportEl.className = 'status ' + (ok ? 'ok' : 'bad');
        reportEl.textContent = (ok ? 'Conforme (emprise + buffer)' : 'Non conforme (emprise + buffer)') +
          ` — rayon: ${rKm} km · ${res.inside}/${res.total} point(s) dans le buffer`;
        detailsEl.innerHTML = 'Le buffer est une somme de Minkowski (offset) de l’emprise à ' + rKm + ' km.';
        return;
      }

      if(eligible.length < 2){
        reportEl.className = 'status warn';
        reportEl.textContent = 'Ajoute au moins deux participants éligibles pour évaluer la distance.';
        detailsEl.textContent = 'Astuce : par défaut, le SDIS est exclu du calcul. Coche l’option si besoin.';
        return;
      }

      if(mode==='free'){
        const {lat0, lon0, pts} = projectLocal(eligible.map(p=>({lat:p.lat, lon:p.lon})));
        const c = mec(pts);
        const centerLL = unprojectLocal(lat0, lon0, c.x, c.y);
        const ok = c.r <= rKm + 1e-9;
        reportEl.className = 'status ' + (ok ? 'ok' : 'bad');
        reportEl.textContent = (ok ? 'Conforme (centre libre)' : 'Non conforme (centre libre)') +
          ` — rayon requis: ${c.r.toFixed(2)} km (seuil: ${rKm} km)`;
        detailsEl.innerHTML = `Centre suggéré: <span class="mono">${centerLL.lat.toFixed(5)}, ${centerLL.lon.toFixed(5)}</span> · Participants couverts: ${eligible.length}`;
        showAccCircle([centerLL.lat, centerLL.lon], c.r, ok ? '#5dd39e' : '#ff5c7a');
        return;
      }

      if(mode==='pair'){
        const {max, pair} = computeMaxDistance(includeSdis);
        const ok = max <= rKm + 1e-9;
        reportEl.className = 'status ' + (ok ? 'ok' : 'bad');
        reportEl.textContent = (ok ? 'Conforme' : 'Non conforme') + ` — distance maximale: ${max.toFixed(2)} km (seuil: ${rKm} km)`;
        if(pair){
          const [a,b] = pair;
          detailsEl.innerHTML = `Participants les plus éloignés: <span class="mono">${a.name}</span> (${humanType(a.type)}) ↔ <span class="mono">${b.name}</span> (${humanType(b.type)}).`;
        } else {
          detailsEl.textContent = '';
        }
        return;
      }
    }

    function setSelected(id){
      selectedPointId = id;
      points.forEach(p=>{
        const el = p.marker.getElement();
        if(el) el.classList.toggle('selected', p.id===id);
      });
    }

    function addPoint(lat, lon, type, name){
      const id = idSeq++;
      const label = name || `${humanType(type)} ${id}`;
      const marker = L.circleMarker([lat, lon], { radius: 7, color: typeColor(type), weight:2, fillColor:typeColor(type), fillOpacity:0.3 }).addTo(map);
      marker.bindPopup(`
        <strong>${label}</strong><br>${humanType(type)}<br>
        <span class="mono">${lat.toFixed(5)}, ${lon.toFixed(5)}</span><br>
        <div style="margin-top:6px;display:flex;gap:6px;">
          <button data-id="${id}" class="popup-del">Supprimer</button>
          <button data-id="${id}" class="popup-rename">Renommer</button>
        </div>
      `, {autoPan:true});
      const entry = {id, name:label, lat, lon, type, marker};

      marker.on('click', (e)=>{
        setSelected(id);
        if(e.originalEvent && e.originalEvent.altKey){ removePoint(id); return; }
      });
      marker.on('contextmenu', ()=>{ removePoint(id); });
      marker.on('popupopen', e=>{
        const root = e.popup.getElement();
        const del = root.querySelector('.popup-del');
        const ren = root.querySelector('.popup-rename');
        if(del) del.addEventListener('click', ()=>{ removePoint(id); map.closePopup(); });
        if(ren) ren.addEventListener('click', ()=>{
          const nn = prompt('Nouveau nom pour ce point:', entry.name);
          if(nn && nn.trim()){
            entry.name = nn.trim();
            marker.setPopupContent(`
              <strong>${entry.name}</strong><br>${humanType(entry.type)}<br>
              <span class="mono">${entry.lat.toFixed(5)}, ${entry.lon.toFixed(5)}</span><br>
              <div style="margin-top:6px;display:flex;gap:6px;">
                <button data-id="${id}" class="popup-del">Supprimer</button>
                <button data-id="${id}" class="popup-rename">Renommer</button>
              </div>
            `);
          }
        });
      });

      points.push(entry);
      updateCount(); refreshCircles(); refreshReport();
    }

    function removePoint(id){
      const idx = points.findIndex(p=>p.id===id);
      if(idx>=0){
        map.removeLayer(points[idx].marker);
        points.splice(idx,1);
        if(selectedPointId===id) selectedPointId=null;
        updateCount(); refreshCircles(); refreshReport();
      }
    }

    // --- Map click add ---
    map.on('click', (e)=>{ addPoint(e.latlng.lat, e.latlng.lng, selectedType()); });

    // --- Keyboard delete ---
    window.addEventListener('keydown', (e)=>{
      if((e.key==='Delete' || e.key==='Backspace') && selectedPointId!=null){ e.preventDefault(); removePoint(selectedPointId); }
    });

    // --- Controls ---
    document.getElementById('clearAll').addEventListener('click', ()=>{
      points.forEach(p=>map.removeLayer(p.marker)); points.length = 0;
      clearCircles(); clearAccCircle(); setSelected(null); updateCount(); refreshReport();
    });
    document.getElementById('fitBtn').addEventListener('click', fitToData);

    document.getElementById('importBtn').addEventListener('click', ()=>{
      const raw = document.getElementById('importArea').value.trim(); if(!raw) return;
      const lines = raw.split(/\r?\n/); let ok=0, fail=0;
      lines.forEach(line=>{
        if(!line.trim()) return;
        const parts = line.split(';').map(s=>s.trim());
        if(parts.length < 4){ fail++; return; }
        const [name, latS, lonS, typeS] = parts;
        const lat = parseFloat(latS), lon = parseFloat(lonS);
        let t = (typeS||'').toLowerCase();
        if(['consumer','consommateur','cons'].includes(t)) t='consumer';
        else if(['producer','producteur','prod'].includes(t)) t='producer';
        else if(['sdis'].includes(t)) t='sdis';
        else { fail++; return; }
        if(isNaN(lat) || isNaN(lon) || lat<-90 || lat>90 || lon<-180 || lon>180){ fail++; return; }
        addPoint(lat, lon, t, name); ok++;
      });
      if(ok){ fitToData(); }
      if(fail){ detailsEl.innerHTML = `Import: ${ok} ligne(s) ajoutée(s), ${fail} rejetée(s). <span class="hint">Format attendu: <span class="mono">Nom;Lat;Lon;Type</span></span>`; }
    });

    document.getElementById('exportCsv').addEventListener('click', ()=>{
      if(points.length===0) return;
      const header = 'name;lat;lon;type';
      const rows = points.map(p=>[p.name.replace(/;/g, ','), p.lat.toFixed(6), p.lon.toFixed(6), p.type].join(';'));
      const csv = [header, ...rows].join('\n');
      const blob = new Blob([csv], {type:'text/csv;charset=utf-8;'});
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a'); a.href = url; a.download = 'acc_etendue_points.csv'; a.click(); URL.revokeObjectURL(url);
    });

    // Emprise import
    document.getElementById('empriseFile').addEventListener('change', async (e)=>{
      const f = e.target.files[0]; if(!f) return;
      const txt = await f.text();
      try{
        const gj = JSON.parse(txt);
        // Sanity: Polygon/MultiPolygon
        let ok = false;
        L.geoJSON(gj, {
          onEachFeature: (feat)=>{ if(['Polygon','MultiPolygon'].includes(feat.geometry.type)) ok = true; }
        });
        if(!ok){ alert('Le GeoJSON doit contenir un Polygon ou MultiPolygon (EPSG:4326).'); return; }
        loadEmpriseGeoJSON(gj);
      }catch(err){
        alert('GeoJSON invalide.');
      }
    });
    document.getElementById('clearEmprise').addEventListener('click', ()=>{ clearEmprise(); refreshReport(); });

    // INSEE overlay
    async function toggleInsee(){
      if(inseeLayer){
        if(inseeVisible){ map.removeLayer(inseeLayer); inseeVisible=false; }
        else { inseeLayer.addTo(map); inseeVisible=true; }
        return;
      }
      try{
        const resp = await fetch('./data/insee_grille.geojson');
        if(!resp.ok) throw new Error('Fichier introuvable');
        const data = await resp.json();
        inseeLayer = L.geoJSON(data, {
          style: f => {
            // Attendu: f.properties.zone = 'rurale'|'periurbaine'|'urbaine' (à adapter selon ton fichier)
            const z = (f.properties?.zone||'').toLowerCase();
            let color = '#8888ff'; // défaut
            if(z.includes('rural')) color = '#5dd39e';
            else if(z.includes('peri')) color = '#ffb020';
            else if(z.includes('urb')) color = '#ff5c7a';
            return {color, weight:1, fillOpacity:0.05};
          }
        }).addTo(map);
        inseeVisible = true;
      }catch(e){
        alert('Impossible de charger /data/insee_grille.geojson. Place le fichier et réessaie.');
      }
    }
    document.getElementById('toggleInsee').addEventListener('click', toggleInsee);

    // IGN activation
    document.getElementById('useIgn').addEventListener('click', ()=>{
      const key = ignKeyEl.value.trim();
      if(!key){ alert('Renseigne ta clé API IGN Geoportail.'); return; }
      if(ignLayer) map.removeLayer(ignLayer);
      // Plan IGN V2 (WMTS)
      ignLayer = L.tileLayer(`https://wxs.ign.fr/${key}/geoportail/wmts?layer=GEOGRAPHICALGRIDSYSTEMS.PLANIGNV2&style=normal&tilematrixset=PM&Service=WMTS&Request=GetTile&Version=1.0.0&Format=image/png&TileMatrix={z}&TileCol={x}&TileRow={y}`, {
        maxZoom: 19, attribution: '© IGN - Géoportail'
      });
      ignLayer.addTo(map);
    });

    // Export image
    document.getElementById('printMap').addEventListener('click', ()=>{ printer.printMap('A4Landscape', 'acc_etendue_carte'); });

    // React to parameter changes
    document.querySelectorAll('input[name="radius"]').forEach(r=>{ r.addEventListener('change', ()=>{ refreshCircles(); refreshReport(); }); });
    customRadiusEl.addEventListener('input', ()=>{ refreshCircles(); refreshReport(); });
    showCirclesEl.addEventListener('change', ()=>{ refreshCircles(); });
    includeSdisEl.addEventListener('change', ()=>{ refreshReport(); });
    [modeFreeEl, modeEmpriseEl, modePairEl].forEach(el=> el.addEventListener('change', ()=>{ refreshReport(); }));

    // Seed example (commenté)
    // addPoint(45.1885, 5.7245, 'consumer', 'Site client Grenoble');
    // addPoint(45.2800, 5.8830, 'producer', 'Centrale PV Voiron');
    // fitToData();
  </script>
</body>
</html>
